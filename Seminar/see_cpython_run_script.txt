Our next presenter is James Bennett who is going to be telling us about CPython internals please make him welcome hi.

So my name is James like Chris. Just told you there's my twitter handle on the slide. I'll probably put these up by Monday ish I hope it's a weekend. I can be lazy. But really I'm not here to show you slides. 
I'm here to tell you a story. story about a Python interpreter and it's friend programmer and they had adventures together.
and the programmer would rate code and the interpreter would run it and you could see the interpreter and isn't it just the most adorable thing you've ever seen in your life and the programmer would come up with code for it to run and the results would make sense every well okay maybe  we confuse to be interpreter.
let's try something a little more straightforward. let's try some simple functions. maybe we just need to calculate I don't know how much time is in a week how many seconds are in a week sometimes we need to count that right and this should be nice and simple these should be about the same well.
maybe we're asking too much of this poor little Python interpreter. maybe we should check and see. if it's feeling all right or maybe there are some things. that aren't necessarily aren't necessarily obvious about how Python works so what I'm going to talk about.
today is the C Python interpreter how it actually works how it runs.
your code how you can understand the life cycle of your code from source to the time it runs how you can poke around and see what the interpreter is doing with your code and if all else fails.
because the answers aren't always in the documentation. how you can actually go look at the C Python source code and sir understanding where to find things and where to look to get answers to some of these questions now this may not be the most practical talk in the world. 
these are things you don't have to know you can have a very successful and long career as a Python programmer without ever having any idea about any of the stuff.
I'm gonna talk about so don't feel like you have to memorize. but it can be neat and if nothing else every once in a  while this will get you some karma on reddit or Stack Overflow. because you'll know how to answer one of these  questions so see Python what exactly is CPython well it's what you get if you go to Python org and download Python.
you get an interpreter called CPython. it's written in C so it's called CPython C. but it's a lot more than just an interpreter, it's  also a parser, it's also a compiler, it's also a virtual machine, it's also the Python standard library or at least an implementation of it. 
it's a programmable C API. it's really a whole bunch of different things that you're getting all in one package that we call the Python interpreter and it actually does a lot of different things. 
let's take kind of a whirlwind tour. 




let's just just look at one of these  functions that we had earlier this is  our slow function so this is how we  write it this is how we work with it  this is how we like to see it but how  does Python see this function well first  of all we can inspect we can grab some  modules out of the standard library and  we can take this function and we can ask  Python to show us how it sees what we  wrote this inspect gets worse by the way  is really handy and I know I said a lot  of things in this talk aren't practical  but a couple years ago when I learned  about inspect not get source I wished I  had known about it 10 years before that  because it is just the handiest thing in  the world you can pass in a function and  it gives you back the string of the  source code of that function so this is  asking Python to show us its abstract  syntax tree we're gonna talk a little  bit more about  what that means but this is how Python  sees that function we wrote that's a  little bit more complicated than what we  initially wrote but we'll understand  this in a minute now the next thing we  need to know is what does Python do with  this function how does Python actually  run this well once again there's a  standard library module we can grab play  around with this and see what Python is  going to do this is the dis module this  is the Python disassembler who's ever  worked with actual like assembly like  low-level programming yeah this is sort  of like that this will let you see what  Python is doing under the hood as it's  running your code and in fact this is  exactly what you get out of it for that  function so this is what python is  actually doing when it's running this  and this is what python is actually  seeing when you hand at that now in  order to understand what's going on here  we need to take a little bit of a detour  we need to talk a little bit about how  computers work just to make sure we're  all on the same page and you know  fortunately there's a very good  explanation of how computers work this  is actually one of my favorite tweets of  all time because it is beautiful and it  is true so inside your computer you have  a CPU a little wafer of silicon with a  bunch of electrical circuits on it and  it's set up in a very clever way but  it's set up in such a way that if you  send certain patterns of electricity  into that little way for a silicon other  patterns of electricity will come out of  it and those patterns are predictable  and in fact it's set up so that certain  types of patterns will cause certain  behaviors and we give these patterns  names we call them instructions and we  say that they mean things like add to  the number in this register to the  number in this register and store it  over here but ultimately these are just  patterns of electricity going in  out of our little CPU are a little way  for a silicon and that's kind of tricky  because that's actually how the computer  works but that's a miserable way for a  human to work who here actually likes  writing assembly anybody anybody okay  one what one hand going up okay  one-and-a-half okay so some of you are  strange and enjoy writing assembly and  you know that that's your thing I won't  chain me for the rest of us well we  prefer to write source code which is  friendly and human readable and human  editable and we can do things with that  but our computer only understands these  these binary instructions we treat them  as binary digits pulses of electricity  going in and out ones and zeros well how  do we get from source code to  instructions now it used to be you  couldn't used to be you just had to sit  down and write instructions for the  processor and that was really not a  great time to be a programmer but then  Admiral grace hopper came along and she  invented the compiler and a compiler is  a wonderful tool because it lets us  write our source code right and a more  readable more expressive human language  and transform that into the instructions  we need for our computer for our  processor so some languages are compiled  we've ever worked with for example C or  C++ or rust or go you feed in source  code to their compiler the compiler  spits out instructions for a particular  type of processor maybe the processor  you're running on maybe some other  processor if you build them for a  different platform some other languages  take a different approach they're  interpreted languages when we say  they're interpreted we mean we just hand  at the source code and it reads the  source code live as the program is  running and translates it into  instructions for the processor and so  that's a different way of running a  program we can just do that as it's  running and take some resources but it's  a thing that works so  given that I've already talked several  times about the Python interpreter at a  sea Python interpreter  maybe they want to guess whether Python  is a compiled language or an interpreted  language  everybody's right so yes  Python is both an interpreted language  and a compiled language uses sort of a  third approach to running code who here  is familiar with Java C sharp I know  there's some Microsoft people in the  house it's okay you can raise your hand  so there's a third approach that some  languages take where they build what's  called a virtual machine instead of  compiling two instructions for the  specific processor that's inside your  computer they build a piece of software  that emulates a processor and it wants  instructions and it knows what to do  with those instructions and then it  translate though translates those  instructions into the actual  instructions for your actual computer  and that set of instructions that we  feed into your virtual machine sometimes  I call that bytecode this is a term  you'll see used in Java in c-sharp all  the dotnet languages all the jvm  languages you'll see used in Python  bytecode is what Python actually runs so  it's providing a virtual machine an  implementation in software of basically  a processor that knows how to execute  these bytecode instructions and you can  find these if you want to who's ever  seen one of those files that Python  leaves behind with the dot py C  extension on the end yeah those are  Python bytecode files one of the first  things python does once it's actually  loaded in parsed and understood your  source code is it compiles it to  bytecode and then it saves one of those  py C files because why do all that work  over again if you don't have to so  that's actually storing the compiled  output of your source code as bytecode  for the Python virtual machine so now we  can actually go back to Python and start  thinking about how does our Python enter  we leave work under the hood but turns  out is actually not that complicated  it's just a few steps the first thing  we're gonna do is give it some source  code and then cpython is going to parse  that generate an abstract syntax tree  from it use that to produce the byte  code and then it's going to run the byte  code what could be what could be  difficult or complicated about that this  is so easy why do I even need 30 minutes  for this talk so we start with the  source code source code is easy right  source code is easy to understand this  was actually legal to do in Python 2 by  the way you could write and I did once  or twice modules in route 13 encoded  text and put one of those little  encoding comments at the top of your  file and it would work Python 3 you're  not allowed to do that anymore you are  you in the room can we bring that back  do I need to write a pep can I write a  pep for it  ok so Python Python 3 which we're all  using right right ok Python 3 assumes  your source code is utf-8 encoded unless  you tell it otherwise with one of these  fancy encoding comments you can do other  types of encoding as you can do utf-16  you can do utf-32 sadly it turns out you  can't use MC deck which means you can't  run it on some old mainframes but  there's a third party module you can add  that gives you an MC deck code for  Python so that's where we start and  Python needs to parse this Python needs  to understand it well fortunately python  has a grammar this is an excerpt from it  I am NOT going to quote the whole thing  at you and in fact I'm not even gonna go  through the whole thing I was gonna  point out if you want to read this you  can there's also a much annotated  version in the Python documentation if  you go to Doc's top python.org and read  the Python language reference it will go  through all of these things and what  they mean these are all the different  types of statements and things that are  syntactically legal in Python and help  Don is supposed to parse them so this is  the first step and from that we're going  to get an abstract syntax tree now  that's kind of a big phrase but  fortunately ast s aren't actually that  complicated to understand they're a tree  structure which means they have a root  and then they have some nodes maybe some  nodes coming off of that so for example  we have an expression 1 plus 2 times 3  this might be a very simple abstract  tree representing that expression our  root node is that multiplication  operator it has two child nodes a plus  and a 3 and then the plus has two more  child nodes 1 and a 2 so that's pretty  much all there is to an abstract syntax  tree right it's easy  well actually pythons abstract syntax  trees are a little bit more complicated  they have a bunch of different types of  nodes if you go read the documentation  for the ast module in the standard  library it'll walk you through how this  works what the different types of nodes  are what they represent  what sorts of things can go on in them  and also we'll give you some utilities  for working with these or if you want to  you can just sit there and start playing  with it so you can see for example this  is our original function we can see the  root of the tree we can see the root  node there has a node that's a function  definition and then we start poking down  further in that we see an assignment  statement we see a return statement you  can walk through this whole thing if you  want to and in fact this is a useful  tool sometimes to know about because you  can do things with abstract syntax trees  that are a lot easier than just trying  to work directly with Python source code  because remember this is a fairly  complex grammar so why not let Python do  the thing that it's good at let Python  parse it for you and give it to you in  this form and there are a lot of tools  that do things like this  is anybody ever actually used the  two-to-three tool that was both to help  you port python 2 to python 3 code uses  abstract syntax trees does anybody used  the security tool bandit it's a static  analyzer for Python code yep  that actually works at the level of the  ast Instagram recently published a blog  post about how they restrict certain  features like side effects at module  import time and they use a tool that  works at the level of the abstract  syntax tree to do this you can grab the  abstract syntax tree for a module you're  about to import and look at it inspect  it say maybe I don't want to allow this  maybe I want to transform it you're  allowed to manipulate this tree at  runtime and in fact there are tools that  will let you do this there are others  will just alert like bandit the security  tool its job is to look for things that  are potentially dangerous to do in your  code and warn you about them so that you  can stop doing those things and if you  want to build on top of that knowledge  there's a couple of good resources out  here green tree snakes is even in fact  recommended I believe by the official  ast module documentation is a place to  go to learn more about Python abstract  syntax trees how to get at them how to  play with them how to work with them and  aster is a library you can just hit  install aster and it gives you some  tools that let you not only grab an  abstract syntax tree and manipulate it  but also serialize it back out to Python  source code if you want to persist that  modified code later on so python parsed  it Python turned it into an abstract  syntax tree what's the next thing we  need to do well obviously we need to  build a code object every single Python  function has one of these you've never  poked at it you can see this it's this  double under code and it's right there  on the actual function itself let's  remember functions are first-class  values they're objects just like  everything else and it has a bunch of  attributes that we can poke around in so  one of these for example is called Co  underscore costs and this is all of the  constant values that were referenced in  the body of that function we have 86,400  and we have seven and we have none there  wasn't a none anywhere in the body of  that function anybody want to guess why  it shows up there  exactly because python has no way of  knowing necessarily whether you're going  to need the implicit return none so the  Python function is running and you get  to the end of that functions code  without hitting an explicit return  statement  Python implicitly returns a nut so it's  going to set that up there and have it  ready for you whether you need it or not  so it's going to be in every constituent  of every function you ever write in  Python and you can see it in there then  there's this Co underscore VAR names  which just is a tuple containing one  entry seconds per day that's our one  local variable that we had in the body  of this function there's also one more  called Co underscore names it would be  an empty tuple for this function this is  any non-local names that were referenced  and we didn't have any of those and then  finally Co underscore code and don't be  fooled by the fact that some of these  print as you know characters that are  kind of recognizable this is a bytes  object these are just those happen to be  bytes whose integer values match up to  ASCII characters so they print as those  characters that's the actual byte code  that Python produced for this function  when it compiled it so let's take a look  at that byte code what's going on in  there we can grab the disk module again  it has this nice big list called op name  which lets us see what each byte value  corresponds to as an instruction you'll  notice I'm skipping by two each time  byte code works like that byte code  comes in two byte units first byte is an  instruction second byte is an argument  to that instruction so we want index 0  to 4 those tell us what are the byte  code instructions in the byte code of  this function by the way that's not  always true on older versions of Python  newer versions of Python the byte code  is nice and we'll do that to byte units  older versions might not so just keep  that in mind so how does it actually run  this well it uses a stack oriented  virtual machine does anybody ever  written forth or factor used a stack  oriented language so a stack you know  very simple data structure supports two  things  push and pop we put things on the top of  the stack we pull things off the top of  the stack turns out that's all you  really need to be able to do to have a  useful model of computation and in fact  the entire bytecode interpreter is built  on stacks first of all there's this main  interpreter stack which has one frame  one item for each function call that has  happened and not yet returned and then  any train we actually have multiple  stacks one is an evaluation stack  sometimes you'll see it called a data  stack this is where it keeps track of  the actual operations that it's doing  the values that it's working with right  now then there's also a thing called a  block stack and the block stack is there  because you can do things like for loops  or with blogs or other blocks that can  nest inside of each other and the  interpreter needs to know how many of  those are active and which one is the  most recent so every time you enter one  of those blocks it pushes on to the  block stack and every time you exit one  of those blocks it pops off the block  stack if you poke around in byte code  you can see those instructions showing  up to push and pop the block stack  they're actually slightly expensive  operations sometimes so that could be a  good performance optimization thing to  look for when you're doing too many of  those anyway so now we can look back at  the byte code that our function produced  and we can actually walk through this  and kind of understand well what's going  on here we got this load contour fast  load consolute fast binary multiply  return value what does that mean that  means okay go grab whatever was it index  1 of CEO counts push it on top of the  evaluation stack then whatever's on top  of the evaluation stack gets stored  under C of our names index 0 then  whatever's at index 2 of CEO counts push  on top of the stack whatever is that  index 0 of C of our names pushed to the  top of the stack whatever the top two  items of the stack are multiply them by  each other push that value on top of the  stack and finally return that's how that  function gets executed that's what that  bytecode is telling Python to do  now I'll be asleep the bytecode  interpreter is a little more complicated  than just these operations but that's a  nice introduction you can go read the  whole thing and in fact I recommend it  it's not that complicated even if you're  not super familiar with see the bytecode  interpreter is really just a gigantic  switch statement where each case in the  switch statement is the name of a  bytecode instruction and tells it what  to do with that instruction so you can  walk through that whole thing and  understand how Python executes bytecode  what each instruction does what sort of  effects it has how Python optimizes some  of these things but there are some fun  optimizations in there and I'm not going  to tell you about them so you'll go read  it you can also go dig around in the C  Python repository and see the  implementations of pythons built-in  types so things like integers or lists  or dictionaries or strings all of these  things are in there implemented in C and  if you look most of them are in the  directory objects in the C Python  repository and sometimes you know if all  else fails if the documentation isn't  helping this is just what you have to do  to go figure out well why did that  behave a certain way why did this happen  instead of that so speaking of how to  get an answer let's finally have a view  of those I bet some of you think you  know why at least one of those initial  slides worked the way it did I'm gonna  throw a twist at you just because I can  and because it's fun but let's start  with this fast and slow now this slow  function is actually we timed it it's  almost one and a half times slower and  the only extra thing it really seems to  be doing is storing something in a  variable is storing a variable really  one-and-a-half times slower than doing  multiplication anybody well let's look  once again here's the code for that  function or the bytecode for that  function here's what it does got one two  three four five six instructions we load  something store something load load  multiply it with time  anybody want to guess what the bytecode  for the fast version looks like exactly  somebody got that right  Python did a little sneaky optimization  here it noticed when this function was  being compiled to bytecode that the only  arithmetic going on there involved  constant literal editor values who is  just 7 times 86,400 there's no reason to  recalculate that at runtime it's not  gonna change  seven times 86,400 is going to be the  same value every single time you do it  so the bytecode compiler when it's  emitting bytecode for this function just  says okay I'll do the math right now and  I get a much simpler function this is  called constant folding it's a very  popular optimization Python bytecode  compiler can do quite a bit of it  sometimes you have to help it a little  bit but it can definitely do these  optimizations for you that maybe you  didn't even know about and that's  actually the secret to why this version  of that function is so much faster than  the version that tried to use a variable  cuz we just look at the difference there  we've got 1 2 3 4 5 6 instructions  versus 2 now the other example we were  looking at was this I bet there are some  people here who know why this works this  way and that's why I'm gonna throw a  twist at you in a moment  but first of all this one we can go look  at the source code we can see why this  happens and it turns out there is a  cache of small integer values rather  than recreate them every time they're  needed Python just initializes them at  the start stores an array of them and  fetches them out whenever it needs to  the is operator compares object identity  and since all of these are the same  object coming back every single time out  of that array that means every single  time you fetch integer 100 it is  actually the same object now this only  runs in default see Python from negative  5 to positive 256 so that's why it  worked for a hundred but it doesn't work  for a thousand  so maybe you knew about the small  manager cash the reason I mentioned this  is somebody asked a question on reddit  about a month and a half ago I think it  was where they'd noticed something that  everybody jumped on and thought was the  small integer cash but it wasn't what if  you fire up Python three point six if  you have a Python three point six  interpreter handy launch it put this end  it really will behave this way this does  not work in Python three point seven  them and that's an interesting change  and I once spent a couple hours on the  main Python IRC channel on a Saturday  afternoon with a couple other people  trying to figure out why exactly this  changed why did this happen one way in  Python 3.6 when it happened the other  way in Python 3.7 this is actually one  of the scenarios that inspired this talk  so what actually is going on here what's  the difference between these two turns  out if you go to Python 3.6 and ask it  to compile one of these statements  compiled as a standalone function you  can ask Python to compile a statement  for you get the code object and start  poking around in it now look at that Co  constants tuple that's a little  interesting we've got our tuple of 1000  1000 which makes sense because we're  assigning a tuple to a tuple but we've  also got the standalone 1000 over there  and we look at it in Python 3.7 it looks  like this  that's an interesting change and it  turns out what happened was between  python 3.6 and python 3.7 they  introduced an ast optimizer that  actually does some more optimizations as  Python is going from the ast to the  bytecode and the code objects for your  code as it's comparsa get compiling and  used to be that when it was building up  this co conscious tuple it would go  through each one of those constant  values and each one of them would  actually get its own  and alone entry in the CEO Constance  tubule which sorted by accident it  doesn't have to be although it's a good  way to do it is backed by hash table so  it actually ended up with the same  instance in each one of those Python 3.7  it gets to avoid creating those  intermediate extra entries in the CEO  comms table and just create that to hold  directly inside CEO counts but as a  result it accidentally D optimized this  specific case because it no longer is  getting to reuse the same integer object  that it originally generated it's  actually generating two different  instances of integer 1000 and that is  why this works on three point six does  not work on three point seven that one  required quite a bit of digging some big  thanks to Ned Batchelder who helped me  out on IRC with figuring that out  hopefully he sees this fine ad anyway so  now we've got some answers now we  understand now we have a toolbox some  ideas for how we can dig into our Python  interpreter and understand what's going  on so if you see something weird that  you don't understand you can't find an  answer in the Python documentation you  know grab the code object poked at it  see what's in the cops what's in the VAR  names what's in the non-local names  what's going on in the bytecode is it  doing anything strange or there are lots  more instructions are there lots fewer  instructions poke at the ASP sometimes  the ast will tell you the difference  between two different things  look for differences in all of these  things and if all else fails sometimes  just go look at the c python source code  once again don't be scared of it it's  not that hard to read even if you don't  know see all that well and finally if  you want to learn a little bit more  here's a couple of useful resources at  the bottom is the actual C Python source  code repository and then up top  wonderful book called inside the Python  virtual machine which will walk you  through a lot more detail than I just  did on how Python parses and runs you  encode as well as this I love this a  Python interpreter written in Python by  Allison captor this is trying to write a  500 line program that is a Python  bytecode interpreter written in Python  so it walks you through how the bytecode  interpreter  works how to handle all of those  different instructions what you need to  have as far as an evaluation stack a  block stack to be able to keep track of  that so if you ought to learn more  there's some resources or feel free to  come find me outside after this or on  Twitter I'll be putting these slides up  in a bit and feel free to tweet at me if  you have more questions and I'll be  happy to follow up in the meantime thank  you all for coming thank you to the  North Bay organizers including Chris  who's hiding back here for inviting me  up here to give this talk I hope you all  have a wonderful rest of your weekend  thanks James  